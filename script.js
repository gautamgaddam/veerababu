if (typeof jQuery === undefined) { throw new Error("Bootstrap's JavaScript requires jQuery") } +function ($) { var version = $.fn.jquery.split(" ")[0].split("."); if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1) { throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher") } }(jQuery); +function ($) { "use strict"; function transitionEnd() { var el = document.createElement("bootstrap"); var transEndEventNames = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" }; for (var name in transEndEventNames) { if (el.style[name] !== undefined) { return { end: transEndEventNames[name] } } } return false } $.fn.emulateTransitionEnd = function (duration) { var called = false; var $el = this; $(this).one("bsTransitionEnd", function () { called = true }); var callback = function () { if (!called) $($el).trigger($.support.transition.end) }; setTimeout(callback, duration); return this }; $(function () { $.support.transition = transitionEnd(); if (!$.support.transition) return; $.event.special.bsTransitionEnd = { bindType: $.support.transition.end, delegateType: $.support.transition.end, handle: function (e) { if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments) } } }) }(jQuery); +function ($) { "use strict"; var dismiss = '[data-dismiss="alert"]'; var Alert = function (el) { $(el).on("click", dismiss, this.close) }; Alert.VERSION = "3.3.1"; Alert.TRANSITION_DURATION = 150; Alert.prototype.close = function (e) { var $this = $(this); var selector = $this.attr("data-target"); if (!selector) { selector = $this.attr("href"); selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "") } var $parent = $(selector); if (e) e.preventDefault(); if (!$parent.length) { $parent = $this.closest(".alert") } $parent.trigger(e = $.Event("close.bs.alert")); if (e.isDefaultPrevented()) return; $parent.removeClass("in"); function removeElement() { $parent.detach().trigger("closed.bs.alert").remove() } $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement() }; function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.alert"); if (!data) $this.data("bs.alert", data = new Alert(this)); if (typeof option == "string") data[option].call($this) }) } var old = $.fn.alert; $.fn.alert = Plugin; $.fn.alert.Constructor = Alert; $.fn.alert.noConflict = function () { $.fn.alert = old; return this }; $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close) }(jQuery); +function ($) { "use strict"; var Button = function (element, options) { this.$element = $(element); this.options = $.extend({}, Button.DEFAULTS, options); this.isLoading = false }; Button.VERSION = "3.3.1"; Button.DEFAULTS = { loadingText: "loading..." }; Button.prototype.setState = function (state) { var d = "disabled"; var $el = this.$element; var val = $el.is("input") ? "val" : "html"; var data = $el.data(); state = state + "Text"; if (data.resetText == null) $el.data("resetText", $el[val]()); setTimeout($.proxy(function () { $el[val](data[state] == null ? this.options[state] : data[state]); if (state == "loadingText") { this.isLoading = true; $el.addClass(d).attr(d, d) } else if (this.isLoading) { this.isLoading = false; $el.removeClass(d).removeAttr(d) } }, this), 0) }; Button.prototype.toggle = function () { var changed = true; var $parent = this.$element.closest('[data-toggle="buttons"]'); if ($parent.length) { var $input = this.$element.find("input"); if ($input.prop("type") == "radio") { if ($input.prop("checked") && this.$element.hasClass("active")) changed = false; else $parent.find(".active").removeClass("active") } if (changed) $input.prop("checked", !this.$element.hasClass("active")).trigger("change") } else { this.$element.attr("aria-pressed", !this.$element.hasClass("active")) } if (changed) this.$element.toggleClass("active") }; function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.button"); var options = typeof option == "object" && option; if (!data) $this.data("bs.button", data = new Button(this, options)); if (option == "toggle") data.toggle(); else if (option) data.setState(option) }) } var old = $.fn.button; $.fn.button = Plugin; $.fn.button.Constructor = Button; $.fn.button.noConflict = function () { $.fn.button = old; return this }; $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (e) { var $btn = $(e.target); if (!$btn.hasClass("btn")) $btn = $btn.closest(".btn"); Plugin.call($btn, "toggle"); e.preventDefault() }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (e) { $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type)) }) }(jQuery); +function ($) { "use strict"; var Carousel = function (element, options) { this.$element = $(element); this.$indicators = this.$element.find(".carousel-indicators"); this.options = options; this.paused = this.sliding = this.interval = this.$active = this.$items = null; this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this)); this.options.pause == "hover" && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this)) }; Carousel.VERSION = "3.3.1"; Carousel.TRANSITION_DURATION = 600; Carousel.DEFAULTS = { interval: 5e3, pause: "hover", wrap: true, keyboard: true }; Carousel.prototype.keydown = function (e) { if (/input|textarea/i.test(e.target.tagName)) return; switch (e.which) { case 37: this.prev(); break; case 39: this.next(); break; default: return }e.preventDefault() }; Carousel.prototype.cycle = function (e) { e || (this.paused = false); this.interval && clearInterval(this.interval); this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval)); return this }; Carousel.prototype.getItemIndex = function (item) { this.$items = item.parent().children(".item"); return this.$items.index(item || this.$active) }; Carousel.prototype.getItemForDirection = function (direction, active) { var delta = direction == "prev" ? -1 : 1; var activeIndex = this.getItemIndex(active); var itemIndex = (activeIndex + delta) % this.$items.length; return this.$items.eq(itemIndex) }; Carousel.prototype.to = function (pos) { var that = this; var activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active")); if (pos > this.$items.length - 1 || pos < 0) return; if (this.sliding) return this.$element.one("slid.bs.carousel", function () { that.to(pos) }); if (activeIndex == pos) return this.pause().cycle(); return this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos)) }; Carousel.prototype.pause = function (e) { e || (this.paused = true); if (this.$element.find(".next, .prev").length && $.support.transition) { this.$element.trigger($.support.transition.end); this.cycle(true) } this.interval = clearInterval(this.interval); return this }; Carousel.prototype.next = function () { if (this.sliding) return; return this.slide("next") }; Carousel.prototype.prev = function () { if (this.sliding) return; return this.slide("prev") }; Carousel.prototype.slide = function (type, next) { var $active = this.$element.find(".item.active"); var $next = next || this.getItemForDirection(type, $active); var isCycling = this.interval; var direction = type == "next" ? "left" : "right"; var fallback = type == "next" ? "first" : "last"; var that = this; if (!$next.length) { if (!this.options.wrap) return; $next = this.$element.find(".item")[fallback]() } if ($next.hasClass("active")) return this.sliding = false; var relatedTarget = $next[0]; var slideEvent = $.Event("slide.bs.carousel", { relatedTarget: relatedTarget, direction: direction }); this.$element.trigger(slideEvent); if (slideEvent.isDefaultPrevented()) return; this.sliding = true; isCycling && this.pause(); if (this.$indicators.length) { this.$indicators.find(".active").removeClass("active"); var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]); $nextIndicator && $nextIndicator.addClass("active") } var slidEvent = $.Event("slid.bs.carousel", { relatedTarget: relatedTarget, direction: direction }); if ($.support.transition && this.$element.hasClass("slide")) { $next.addClass(type); $next[0].offsetWidth; $active.addClass(direction); $next.addClass(direction); $active.one("bsTransitionEnd", function () { $next.removeClass([type, direction].join(" ")).addClass("active"); $active.removeClass(["active", direction].join(" ")); that.sliding = false; setTimeout(function () { that.$element.trigger(slidEvent) }, 0) }).emulateTransitionEnd(Carousel.TRANSITION_DURATION) } else { $active.removeClass("active"); $next.addClass("active"); this.sliding = false; this.$element.trigger(slidEvent) } isCycling && this.cycle(); return this }; function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.carousel"); var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == "object" && option); var action = typeof option == "string" ? option : options.slide; if (!data) $this.data("bs.carousel", data = new Carousel(this, options)); if (typeof option == "number") data.to(option); else if (action) data[action](); else if (options.interval) data.pause().cycle() }) } var old = $.fn.carousel; $.fn.carousel = Plugin; $.fn.carousel.Constructor = Carousel; $.fn.carousel.noConflict = function () { $.fn.carousel = old; return this }; var clickHandler = function (e) { var href; var $this = $(this); var $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "")); if (!$target.hasClass("carousel")) return; var options = $.extend({}, $target.data(), $this.data()); var slideIndex = $this.attr("data-slide-to"); if (slideIndex) options.interval = false; Plugin.call($target, options); if (slideIndex) { $target.data("bs.carousel").to(slideIndex) } e.preventDefault() }; $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler); $(window).on("load", function () { $('[data-ride="carousel"]').each(function () { var $carousel = $(this); Plugin.call($carousel, $carousel.data()) }) }) }(jQuery); +function ($) { "use strict"; var Collapse = function (element, options) { this.$element = $(element); this.options = $.extend({}, Collapse.DEFAULTS, options); this.$trigger = $(this.options.trigger).filter('[href="#' + element.id + '"], [data-target="#' + element.id + '"]'); this.transitioning = null; if (this.options.parent) { this.$parent = this.getParent() } else { this.addAriaAndCollapsedClass(this.$element, this.$trigger) } if (this.options.toggle) this.toggle() }; Collapse.VERSION = "3.3.1"; Collapse.TRANSITION_DURATION = 350; Collapse.DEFAULTS = { toggle: true, trigger: '[data-toggle="collapse"]' }; Collapse.prototype.dimension = function () { var hasWidth = this.$element.hasClass("width"); return hasWidth ? "width" : "height" }; Collapse.prototype.show = function () { if (this.transitioning || this.$element.hasClass("in")) return; var activesData; var actives = this.$parent && this.$parent.find("> .panel").children(".in, .collapsing"); if (actives && actives.length) { activesData = actives.data("bs.collapse"); if (activesData && activesData.transitioning) return } var startEvent = $.Event("show.bs.collapse"); this.$element.trigger(startEvent); if (startEvent.isDefaultPrevented()) return; if (actives && actives.length) { Plugin.call(actives, "hide"); activesData || actives.data("bs.collapse", null) } var dimension = this.dimension(); this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", true); this.$trigger.removeClass("collapsed").attr("aria-expanded", true); this.transitioning = 1; var complete = function () { this.$element.removeClass("collapsing").addClass("collapse in")[dimension](""); this.transitioning = 0; this.$element.trigger("shown.bs.collapse") }; if (!$.support.transition) return complete.call(this); var scrollSize = $.camelCase(["scroll", dimension].join("-")); this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]) }; Collapse.prototype.hide = function () { if (this.transitioning || !this.$element.hasClass("in")) return; var startEvent = $.Event("hide.bs.collapse"); this.$element.trigger(startEvent); if (startEvent.isDefaultPrevented()) return; var dimension = this.dimension(); this.$element[dimension](this.$element[dimension]())[0].offsetHeight; this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", false); this.$trigger.addClass("collapsed").attr("aria-expanded", false); this.transitioning = 1; var complete = function () { this.transitioning = 0; this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse") }; if (!$.support.transition) return complete.call(this); this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION) }; Collapse.prototype.toggle = function () { this[this.$element.hasClass("in") ? "hide" : "show"]() }; Collapse.prototype.getParent = function () { return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) { var $element = $(element); this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element) }, this)).end() }; Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) { var isOpen = $element.hasClass("in"); $element.attr("aria-expanded", isOpen); $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen) }; function getTargetFromTrigger($trigger) { var href; var target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""); return $(target) } function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.collapse"); var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == "object" && option); if (!data && options.toggle && option == "show") options.toggle = false; if (!data) $this.data("bs.collapse", data = new Collapse(this, options)); if (typeof option == "string") data[option]() }) } var old = $.fn.collapse; $.fn.collapse = Plugin; $.fn.collapse.Constructor = Collapse; $.fn.collapse.noConflict = function () { $.fn.collapse = old; return this }; $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (e) { var $this = $(this); if (!$this.attr("data-target")) e.preventDefault(); var $target = getTargetFromTrigger($this); var data = $target.data("bs.collapse"); var option = data ? "toggle" : $.extend({}, $this.data(), { trigger: this }); Plugin.call($target, option) }) }(jQuery); +function ($) { "use strict"; var backdrop = ".dropdown-backdrop"; var toggle = '[data-toggle="dropdown"]'; var Dropdown = function (element) { $(element).on("click.bs.dropdown", this.toggle) }; Dropdown.VERSION = "3.3.1"; Dropdown.prototype.toggle = function (e) { var $this = $(this); if ($this.is(".disabled, :disabled")) return; var $parent = getParent($this); var isActive = $parent.hasClass("open"); clearMenus(); if (!isActive) { if ("ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length) { $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on("click", clearMenus) } var relatedTarget = { relatedTarget: this }; $parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget)); if (e.isDefaultPrevented()) return; $this.trigger("focus").attr("aria-expanded", "true"); $parent.toggleClass("open").trigger("shown.bs.dropdown", relatedTarget) } return false }; Dropdown.prototype.keydown = function (e) { if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return; var $this = $(this); e.preventDefault(); e.stopPropagation(); if ($this.is(".disabled, :disabled")) return; var $parent = getParent($this); var isActive = $parent.hasClass("open"); if (!isActive && e.which != 27 || isActive && e.which == 27) { if (e.which == 27) $parent.find(toggle).trigger("focus"); return $this.trigger("click") } var desc = " li:not(.divider):visible a"; var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc); if (!$items.length) return; var index = $items.index(e.target); if (e.which == 38 && index > 0) index--; if (e.which == 40 && index < $items.length - 1) index++; if (!~index) index = 0; $items.eq(index).trigger("focus") }; function clearMenus(e) { if (e && e.which === 3) return; $(backdrop).remove(); $(toggle).each(function () { var $this = $(this); var $parent = getParent($this); var relatedTarget = { relatedTarget: this }; if (!$parent.hasClass("open")) return; $parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget)); if (e.isDefaultPrevented()) return; $this.attr("aria-expanded", "false"); $parent.removeClass("open").trigger("hidden.bs.dropdown", relatedTarget) }) } function getParent($this) { var selector = $this.attr("data-target"); if (!selector) { selector = $this.attr("href"); selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, "") } var $parent = selector && $(selector); return $parent && $parent.length ? $parent : $this.parent() } function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.dropdown"); if (!data) $this.data("bs.dropdown", data = new Dropdown(this)); if (typeof option == "string") data[option].call($this) }) } var old = $.fn.dropdown; $.fn.dropdown = Plugin; $.fn.dropdown.Constructor = Dropdown; $.fn.dropdown.noConflict = function () { $.fn.dropdown = old; return this }; $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function (e) { e.stopPropagation() }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="menu"]', Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="listbox"]', Dropdown.prototype.keydown) }(jQuery); +function ($) { "use strict"; var Modal = function (element, options) { this.options = options; this.$body = $(document.body); this.$element = $(element); this.$backdrop = this.isShown = null; this.scrollbarWidth = 0; if (this.options.remote) { this.$element.find(".modal-content").load(this.options.remote, $.proxy(function () { this.$element.trigger("loaded.bs.modal") }, this)) } }; Modal.VERSION = "3.3.1"; Modal.TRANSITION_DURATION = 300; Modal.BACKDROP_TRANSITION_DURATION = 150; Modal.DEFAULTS = { backdrop: true, keyboard: true, show: true }; Modal.prototype.toggle = function (_relatedTarget) { return this.isShown ? this.hide() : this.show(_relatedTarget) }; Modal.prototype.show = function (_relatedTarget) { var that = this; var e = $.Event("show.bs.modal", { relatedTarget: _relatedTarget }); this.$element.trigger(e); if (this.isShown || e.isDefaultPrevented()) return; this.isShown = true; this.checkScrollbar(); this.setScrollbar(); this.$body.addClass("modal-open"); this.escape(); this.resize(); this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this)); this.backdrop(function () { var transition = $.support.transition && that.$element.hasClass("fade"); if (!that.$element.parent().length) { that.$element.appendTo(that.$body) } that.$element.show().scrollTop(0); if (that.options.backdrop) that.adjustBackdrop(); that.adjustDialog(); if (transition) { that.$element[0].offsetWidth } that.$element.addClass("in").attr("aria-hidden", false); that.enforceFocus(); var e = $.Event("shown.bs.modal", { relatedTarget: _relatedTarget }); transition ? that.$element.find(".modal-dialog").one("bsTransitionEnd", function () { that.$element.trigger("focus").trigger(e) }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e) }) }; Modal.prototype.hide = function (e) { if (e) e.preventDefault(); e = $.Event("hide.bs.modal"); this.$element.trigger(e); if (!this.isShown || e.isDefaultPrevented()) return; this.isShown = false; this.escape(); this.resize(); $(document).off("focusin.bs.modal"); this.$element.removeClass("in").attr("aria-hidden", true).off("click.dismiss.bs.modal"); $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal() }; Modal.prototype.enforceFocus = function () { $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function (e) { if (this.$element[0] !== e.target && !this.$element.has(e.target).length) { this.$element.trigger("focus") } }, this)) }; Modal.prototype.escape = function () { if (this.isShown && this.options.keyboard) { this.$element.on("keydown.dismiss.bs.modal", $.proxy(function (e) { e.which == 27 && this.hide() }, this)) } else if (!this.isShown) { this.$element.off("keydown.dismiss.bs.modal") } }; Modal.prototype.resize = function () { if (this.isShown) { $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this)) } else { $(window).off("resize.bs.modal") } }; Modal.prototype.hideModal = function () { var that = this; this.$element.hide(); this.backdrop(function () { that.$body.removeClass("modal-open"); that.resetAdjustments(); that.resetScrollbar(); that.$element.trigger("hidden.bs.modal") }) }; Modal.prototype.removeBackdrop = function () { this.$backdrop && this.$backdrop.remove(); this.$backdrop = null }; Modal.prototype.backdrop = function (callback) { var that = this; var animate = this.$element.hasClass("fade") ? "fade" : ""; if (this.isShown && this.options.backdrop) { var doAnimate = $.support.transition && animate; this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').prependTo(this.$element).on("click.dismiss.bs.modal", $.proxy(function (e) { if (e.target !== e.currentTarget) return; this.options.backdrop == "static" ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this) }, this)); if (doAnimate) this.$backdrop[0].offsetWidth; this.$backdrop.addClass("in"); if (!callback) return; doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback() } else if (!this.isShown && this.$backdrop) { this.$backdrop.removeClass("in"); var callbackRemove = function () { that.removeBackdrop(); callback && callback() }; $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove() } else if (callback) { callback() } }; Modal.prototype.handleUpdate = function () { if (this.options.backdrop) this.adjustBackdrop(); this.adjustDialog() }; Modal.prototype.adjustBackdrop = function () { this.$backdrop.css("height", 0).css("height", this.$element[0].scrollHeight) }; Modal.prototype.adjustDialog = function () { var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight; this.$element.css({ paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "", paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : "" }) }; Modal.prototype.resetAdjustments = function () { this.$element.css({ paddingLeft: "", paddingRight: "" }) }; Modal.prototype.checkScrollbar = function () { this.bodyIsOverflowing = document.body.scrollHeight > document.documentElement.clientHeight; this.scrollbarWidth = this.measureScrollbar() }; Modal.prototype.setScrollbar = function () { var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10); if (this.bodyIsOverflowing) this.$body.css("padding-right", bodyPad + this.scrollbarWidth) }; Modal.prototype.resetScrollbar = function () { this.$body.css("padding-right", "") }; Modal.prototype.measureScrollbar = function () { var scrollDiv = document.createElement("div"); scrollDiv.className = "modal-scrollbar-measure"; this.$body.append(scrollDiv); var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth; this.$body[0].removeChild(scrollDiv); return scrollbarWidth }; function Plugin(option, _relatedTarget) { return this.each(function () { var $this = $(this); var data = $this.data("bs.modal"); var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == "object" && option); if (!data) $this.data("bs.modal", data = new Modal(this, options)); if (typeof option == "string") data[option](_relatedTarget); else if (options.show) data.show(_relatedTarget) }) } var old = $.fn.modal; $.fn.modal = Plugin; $.fn.modal.Constructor = Modal; $.fn.modal.noConflict = function () { $.fn.modal = old; return this }; $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (e) { var $this = $(this); var href = $this.attr("href"); var $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, "")); var option = $target.data("bs.modal") ? "toggle" : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data()); if ($this.is("a")) e.preventDefault(); $target.one("show.bs.modal", function (showEvent) { if (showEvent.isDefaultPrevented()) return; $target.one("hidden.bs.modal", function () { $this.is(":visible") && $this.trigger("focus") }) }); Plugin.call($target, option, this) }) }(jQuery); +function ($) { "use strict"; var Tooltip = function (element, options) { this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null; this.init("tooltip", element, options) }; Tooltip.VERSION = "3.3.1"; Tooltip.TRANSITION_DURATION = 150; Tooltip.DEFAULTS = { animation: true, placement: "top", selector: false, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: false, container: false, viewport: { selector: "body", padding: 0 } }; Tooltip.prototype.init = function (type, element, options) { this.enabled = true; this.type = type; this.$element = $(element); this.options = this.getOptions(options); this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport); var triggers = this.options.trigger.split(" "); for (var i = triggers.length; i--;) { var trigger = triggers[i]; if (trigger == "click") { this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this)) } else if (trigger != "manual") { var eventIn = trigger == "hover" ? "mouseenter" : "focusin"; var eventOut = trigger == "hover" ? "mouseleave" : "focusout"; this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this)); this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this)) } } this.options.selector ? this._options = $.extend({}, this.options, { trigger: "manual", selector: "" }) : this.fixTitle() }; Tooltip.prototype.getDefaults = function () { return Tooltip.DEFAULTS }; Tooltip.prototype.getOptions = function (options) { options = $.extend({}, this.getDefaults(), this.$element.data(), options); if (options.delay && typeof options.delay == "number") { options.delay = { show: options.delay, hide: options.delay } } return options }; Tooltip.prototype.getDelegateOptions = function () { var options = {}; var defaults = this.getDefaults(); this._options && $.each(this._options, function (key, value) { if (defaults[key] != value) options[key] = value }); return options }; Tooltip.prototype.enter = function (obj) { var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type); if (self && self.$tip && self.$tip.is(":visible")) { self.hoverState = "in"; return } if (!self) { self = new this.constructor(obj.currentTarget, this.getDelegateOptions()); $(obj.currentTarget).data("bs." + this.type, self) } clearTimeout(self.timeout); self.hoverState = "in"; if (!self.options.delay || !self.options.delay.show) return self.show(); self.timeout = setTimeout(function () { if (self.hoverState == "in") self.show() }, self.options.delay.show) }; Tooltip.prototype.leave = function (obj) { var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type); if (!self) { self = new this.constructor(obj.currentTarget, this.getDelegateOptions()); $(obj.currentTarget).data("bs." + this.type, self) } clearTimeout(self.timeout); self.hoverState = "out"; if (!self.options.delay || !self.options.delay.hide) return self.hide(); self.timeout = setTimeout(function () { if (self.hoverState == "out") self.hide() }, self.options.delay.hide) }; Tooltip.prototype.show = function () { var e = $.Event("show.bs." + this.type); if (this.hasContent() && this.enabled) { this.$element.trigger(e); var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]); if (e.isDefaultPrevented() || !inDom) return; var that = this; var $tip = this.tip(); var tipId = this.getUID(this.type); this.setContent(); $tip.attr("id", tipId); this.$element.attr("aria-describedby", tipId); if (this.options.animation) $tip.addClass("fade"); var placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement; var autoToken = /\s?auto?\s?/i; var autoPlace = autoToken.test(placement); if (autoPlace) placement = placement.replace(autoToken, "") || "top"; $tip.detach().css({ top: 0, left: 0, display: "block" }).addClass(placement).data("bs." + this.type, this); this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element); var pos = this.getPosition(); var actualWidth = $tip[0].offsetWidth; var actualHeight = $tip[0].offsetHeight; if (autoPlace) { var orgPlacement = placement; var $container = this.options.container ? $(this.options.container) : this.$element.parent(); var containerDim = this.getPosition($container); placement = placement == "bottom" && pos.bottom + actualHeight > containerDim.bottom ? "top" : placement == "top" && pos.top - actualHeight < containerDim.top ? "bottom" : placement == "right" && pos.right + actualWidth > containerDim.width ? "left" : placement == "left" && pos.left - actualWidth < containerDim.left ? "right" : placement; $tip.removeClass(orgPlacement).addClass(placement) } var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight); this.applyPlacement(calculatedOffset, placement); var complete = function () { var prevHoverState = that.hoverState; that.$element.trigger("shown.bs." + that.type); that.hoverState = null; if (prevHoverState == "out") that.leave(that) }; $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete() } }; Tooltip.prototype.applyPlacement = function (offset, placement) { var $tip = this.tip(); var width = $tip[0].offsetWidth; var height = $tip[0].offsetHeight; var marginTop = parseInt($tip.css("margin-top"), 10); var marginLeft = parseInt($tip.css("margin-left"), 10); if (isNaN(marginTop)) marginTop = 0; if (isNaN(marginLeft)) marginLeft = 0; offset.top = offset.top + marginTop; offset.left = offset.left + marginLeft; $.offset.setOffset($tip[0], $.extend({ using: function (props) { $tip.css({ top: Math.round(props.top), left: Math.round(props.left) }) } }, offset), 0); $tip.addClass("in"); var actualWidth = $tip[0].offsetWidth; var actualHeight = $tip[0].offsetHeight; if (placement == "top" && actualHeight != height) { offset.top = offset.top + height - actualHeight } var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight); if (delta.left) offset.left += delta.left; else offset.top += delta.top; var isVertical = /top|bottom/.test(placement); var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight; var arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight"; $tip.offset(offset); this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical) }; Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) { this.arrow().css(isHorizontal ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isHorizontal ? "top" : "left", "") }; Tooltip.prototype.setContent = function () { var $tip = this.tip(); var title = this.getTitle(); $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title); $tip.removeClass("fade in top bottom left right") }; Tooltip.prototype.hide = function (callback) { var that = this; var $tip = this.tip(); var e = $.Event("hide.bs." + this.type); function complete() { if (that.hoverState != "in") $tip.detach(); that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type); callback && callback() } this.$element.trigger(e); if (e.isDefaultPrevented()) return; $tip.removeClass("in"); $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete(); this.hoverState = null; return this }; Tooltip.prototype.fixTitle = function () { var $e = this.$element; if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") { $e.attr("data-original-title", $e.attr("title") || "").attr("title", "") } }; Tooltip.prototype.hasContent = function () { return this.getTitle() }; Tooltip.prototype.getPosition = function ($element) { $element = $element || this.$element; var el = $element[0]; var isBody = el.tagName == "BODY"; var elRect = el.getBoundingClientRect(); if (elRect.width == null) { elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top }) } var elOffset = isBody ? { top: 0, left: 0 } : $element.offset(); var scroll = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }; var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null; return $.extend({}, elRect, scroll, outerDims, elOffset) }; Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) { return placement == "bottom" ? { top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == "top" ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == "left" ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } : { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width } }; Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) { var delta = { top: 0, left: 0 }; if (!this.$viewport) return delta; var viewportPadding = this.options.viewport && this.options.viewport.padding || 0; var viewportDimensions = this.getPosition(this.$viewport); if (/right|left/.test(placement)) { var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll; var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight; if (topEdgeOffset < viewportDimensions.top) { delta.top = viewportDimensions.top - topEdgeOffset } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset } } else { var leftEdgeOffset = pos.left - viewportPadding; var rightEdgeOffset = pos.left + viewportPadding + actualWidth; if (leftEdgeOffset < viewportDimensions.left) { delta.left = viewportDimensions.left - leftEdgeOffset } else if (rightEdgeOffset > viewportDimensions.width) { delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset } } return delta }; Tooltip.prototype.getTitle = function () { var title; var $e = this.$element; var o = this.options; title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title); return title }; Tooltip.prototype.getUID = function (prefix) { do { prefix += ~~(Math.random() * 1e6) } while (document.getElementById(prefix)); return prefix }; Tooltip.prototype.tip = function () { return this.$tip = this.$tip || $(this.options.template) }; Tooltip.prototype.arrow = function () { return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow") }; Tooltip.prototype.enable = function () { this.enabled = true }; Tooltip.prototype.disable = function () { this.enabled = false }; Tooltip.prototype.toggleEnabled = function () { this.enabled = !this.enabled }; Tooltip.prototype.toggle = function (e) { var self = this; if (e) { self = $(e.currentTarget).data("bs." + this.type); if (!self) { self = new this.constructor(e.currentTarget, this.getDelegateOptions()); $(e.currentTarget).data("bs." + this.type, self) } } self.tip().hasClass("in") ? self.leave(self) : self.enter(self) }; Tooltip.prototype.destroy = function () { var that = this; clearTimeout(this.timeout); this.hide(function () { that.$element.off("." + that.type).removeData("bs." + that.type) }) }; function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.tooltip"); var options = typeof option == "object" && option; var selector = options && options.selector; if (!data && option == "destroy") return; if (selector) { if (!data) $this.data("bs.tooltip", data = {}); if (!data[selector]) data[selector] = new Tooltip(this, options) } else { if (!data) $this.data("bs.tooltip", data = new Tooltip(this, options)) } if (typeof option == "string") data[option]() }) } var old = $.fn.tooltip; $.fn.tooltip = Plugin; $.fn.tooltip.Constructor = Tooltip; $.fn.tooltip.noConflict = function () { $.fn.tooltip = old; return this } }(jQuery); +function ($) { "use strict"; var Popover = function (element, options) { this.init("popover", element, options) }; if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js"); Popover.VERSION = "3.3.1"; Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, { placement: "right", trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>' }); Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype); Popover.prototype.constructor = Popover; Popover.prototype.getDefaults = function () { return Popover.DEFAULTS }; Popover.prototype.setContent = function () { var $tip = this.tip(); var title = this.getTitle(); var content = this.getContent(); $tip.find(".popover-title")[this.options.html ? "html" : "text"](title); $tip.find(".popover-content").children().detach().end()[this.options.html ? typeof content == "string" ? "html" : "append" : "text"](content); $tip.removeClass("fade top bottom left right in"); if (!$tip.find(".popover-title").html()) $tip.find(".popover-title").hide() }; Popover.prototype.hasContent = function () { return this.getTitle() || this.getContent() }; Popover.prototype.getContent = function () { var $e = this.$element; var o = this.options; return $e.attr("data-content") || (typeof o.content == "function" ? o.content.call($e[0]) : o.content) }; Popover.prototype.arrow = function () { return this.$arrow = this.$arrow || this.tip().find(".arrow") }; Popover.prototype.tip = function () { if (!this.$tip) this.$tip = $(this.options.template); return this.$tip }; function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.popover"); var options = typeof option == "object" && option; var selector = options && options.selector; if (!data && option == "destroy") return; if (selector) { if (!data) $this.data("bs.popover", data = {}); if (!data[selector]) data[selector] = new Popover(this, options) } else { if (!data) $this.data("bs.popover", data = new Popover(this, options)) } if (typeof option == "string") data[option]() }) } var old = $.fn.popover; $.fn.popover = Plugin; $.fn.popover.Constructor = Popover; $.fn.popover.noConflict = function () { $.fn.popover = old; return this } }(jQuery); +function ($) { "use strict"; function ScrollSpy(element, options) { var process = $.proxy(this.process, this); this.$body = $("body"); this.$scrollElement = $(element).is("body") ? $(window) : $(element); this.options = $.extend({}, ScrollSpy.DEFAULTS, options); this.selector = (this.options.target || "") + " .nav li > a"; this.offsets = []; this.targets = []; this.activeTarget = null; this.scrollHeight = 0; this.$scrollElement.on("scroll.bs.scrollspy", process); this.refresh(); this.process() } ScrollSpy.VERSION = "3.3.1"; ScrollSpy.DEFAULTS = { offset: 10 }; ScrollSpy.prototype.getScrollHeight = function () { return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight) }; ScrollSpy.prototype.refresh = function () { var offsetMethod = "offset"; var offsetBase = 0; if (!$.isWindow(this.$scrollElement[0])) { offsetMethod = "position"; offsetBase = this.$scrollElement.scrollTop() } this.offsets = []; this.targets = []; this.scrollHeight = this.getScrollHeight(); var self = this; this.$body.find(this.selector).map(function () { var $el = $(this); var href = $el.data("target") || $el.attr("href"); var $href = /^#./.test(href) && $(href); return $href && $href.length && $href.is(":visible") && [[$href[offsetMethod]().top + offsetBase, href]] || null }).sort(function (a, b) { return a[0] - b[0] }).each(function () { self.offsets.push(this[0]); self.targets.push(this[1]) }) }; ScrollSpy.prototype.process = function () { var scrollTop = this.$scrollElement.scrollTop() + this.options.offset; var scrollHeight = this.getScrollHeight(); var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height(); var offsets = this.offsets; var targets = this.targets; var activeTarget = this.activeTarget; var i; if (this.scrollHeight != scrollHeight) { this.refresh() } if (scrollTop >= maxScroll) { return activeTarget != (i = targets[targets.length - 1]) && this.activate(i) } if (activeTarget && scrollTop < offsets[0]) { this.activeTarget = null; return this.clear() } for (i = offsets.length; i--;) { activeTarget != targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop <= offsets[i + 1]) && this.activate(targets[i]) } }; ScrollSpy.prototype.activate = function (target) { this.activeTarget = target; this.clear(); var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]'; var active = $(selector).parents("li").addClass("active"); if (active.parent(".dropdown-menu").length) { active = active.closest("li.dropdown").addClass("active") } active.trigger("activate.bs.scrollspy") }; ScrollSpy.prototype.clear = function () { $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active") }; function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.scrollspy"); var options = typeof option == "object" && option; if (!data) $this.data("bs.scrollspy", data = new ScrollSpy(this, options)); if (typeof option == "string") data[option]() }) } var old = $.fn.scrollspy; $.fn.scrollspy = Plugin; $.fn.scrollspy.Constructor = ScrollSpy; $.fn.scrollspy.noConflict = function () { $.fn.scrollspy = old; return this }; $(window).on("load.bs.scrollspy.data-api", function () { $('[data-spy="scroll"]').each(function () { var $spy = $(this); Plugin.call($spy, $spy.data()) }) }) }(jQuery); +function ($) { "use strict"; var Tab = function (element) { this.element = $(element) }; Tab.VERSION = "3.3.1"; Tab.TRANSITION_DURATION = 150; Tab.prototype.show = function () { var $this = this.element; var $ul = $this.closest("ul:not(.dropdown-menu)"); var selector = $this.data("target"); if (!selector) { selector = $this.attr("href"); selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "") } if ($this.parent("li").hasClass("active")) return; var $previous = $ul.find(".active:last a"); var hideEvent = $.Event("hide.bs.tab", { relatedTarget: $this[0] }); var showEvent = $.Event("show.bs.tab", { relatedTarget: $previous[0] }); $previous.trigger(hideEvent); $this.trigger(showEvent); if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return; var $target = $(selector); this.activate($this.closest("li"), $ul); this.activate($target, $target.parent(), function () { $previous.trigger({ type: "hidden.bs.tab", relatedTarget: $this[0] }); $this.trigger({ type: "shown.bs.tab", relatedTarget: $previous[0] }) }) }; Tab.prototype.activate = function (element, container, callback) { var $active = container.find("> .active"); var transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length); function next() { $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false); element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true); if (transition) { element[0].offsetWidth; element.addClass("in") } else { element.removeClass("fade") } if (element.parent(".dropdown-menu")) { element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true) } callback && callback() } $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next(); $active.removeClass("in") }; function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.tab"); if (!data) $this.data("bs.tab", data = new Tab(this)); if (typeof option == "string") data[option]() }) } var old = $.fn.tab; $.fn.tab = Plugin; $.fn.tab.Constructor = Tab; $.fn.tab.noConflict = function () { $.fn.tab = old; return this }; var clickHandler = function (e) { e.preventDefault(); Plugin.call($(this), "show") }; $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler) }(jQuery); +function ($) { "use strict"; var Affix = function (element, options) { this.options = $.extend({}, Affix.DEFAULTS, options); this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this)); this.$element = $(element); this.affixed = this.unpin = this.pinnedOffset = null; this.checkPosition() }; Affix.VERSION = "3.3.1"; Affix.RESET = "affix affix-top affix-bottom"; Affix.DEFAULTS = { offset: 0, target: window }; Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) { var scrollTop = this.$target.scrollTop(); var position = this.$element.offset(); var targetHeight = this.$target.height(); if (offsetTop != null && this.affixed == "top") return scrollTop < offsetTop ? "top" : false; if (this.affixed == "bottom") { if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : "bottom"; return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : "bottom" } var initializing = this.affixed == null; var colliderTop = initializing ? scrollTop : position.top; var colliderHeight = initializing ? targetHeight : height; if (offsetTop != null && colliderTop <= offsetTop) return "top"; if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return "bottom"; return false }; Affix.prototype.getPinnedOffset = function () { if (this.pinnedOffset) return this.pinnedOffset; this.$element.removeClass(Affix.RESET).addClass("affix"); var scrollTop = this.$target.scrollTop(); var position = this.$element.offset(); return this.pinnedOffset = position.top - scrollTop }; Affix.prototype.checkPositionWithEventLoop = function () { setTimeout($.proxy(this.checkPosition, this), 1) }; Affix.prototype.checkPosition = function () { if (!this.$element.is(":visible")) return; var height = this.$element.height(); var offset = this.options.offset; var offsetTop = offset.top; var offsetBottom = offset.bottom; var scrollHeight = $("body").height(); if (typeof offset != "object") offsetBottom = offsetTop = offset; if (typeof offsetTop == "function") offsetTop = offset.top(this.$element); if (typeof offsetBottom == "function") offsetBottom = offset.bottom(this.$element); var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom); if (this.affixed != affix) { if (this.unpin != null) this.$element.css("top", ""); var affixType = "affix" + (affix ? "-" + affix : ""); var e = $.Event(affixType + ".bs.affix"); this.$element.trigger(e); if (e.isDefaultPrevented()) return; this.affixed = affix; this.unpin = affix == "bottom" ? this.getPinnedOffset() : null; this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix") } if (affix == "bottom") { this.$element.offset({ top: scrollHeight - height - offsetBottom }) } }; function Plugin(option) { return this.each(function () { var $this = $(this); var data = $this.data("bs.affix"); var options = typeof option == "object" && option; if (!data) $this.data("bs.affix", data = new Affix(this, options)); if (typeof option == "string") data[option]() }) } var old = $.fn.affix; $.fn.affix = Plugin; $.fn.affix.Constructor = Affix; $.fn.affix.noConflict = function () { $.fn.affix = old; return this }; $(window).on("load", function () { $('[data-spy="affix"]').each(function () { var $spy = $(this); var data = $spy.data(); data.offset = data.offset || {}; if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom; if (data.offsetTop != null) data.offset.top = data.offsetTop; Plugin.call($spy, data) }) }) }(jQuery); (function () { var root = typeof exports === "undefined" ? window : exports; var config = { retinaImageSuffix: "@2x", check_mime_type: true, force_original_dimensions: true }; function Retina() { } root.Retina = Retina; Retina.configure = function (options) { if (options === null) { options = {} } for (var prop in options) { if (options.hasOwnProperty(prop)) { config[prop] = options[prop] } } }; Retina.init = function (context) { if (context === null) { context = root } var existing_onload = context.onload || function () { }; context.onload = function () { var images = document.getElementsByTagName("img"), retinaImages = [], i, image; for (i = 0; i < images.length; i += 1) { image = images[i]; if (!!!image.getAttributeNode("data-no-retina")) { retinaImages.push(new RetinaImage(image)) } } existing_onload() } }; Retina.isRetina = function () { var mediaQuery = "(-webkit-min-device-pixel-ratio: 1.5), (min--moz-device-pixel-ratio: 1.5), (-o-min-device-pixel-ratio: 3/2), (min-resolution: 1.5dppx)"; if (root.devicePixelRatio > 1) { return true } if (root.matchMedia && root.matchMedia(mediaQuery).matches) { return true } return false }; var regexMatch = /\.\w+$/; function suffixReplace(match) { return config.retinaImageSuffix + match } function RetinaImagePath(path, at_2x_path) { this.path = path || ""; if (typeof at_2x_path !== "undefined" && at_2x_path !== null) { this.at_2x_path = at_2x_path; this.perform_check = false } else { if (undefined !== document.createElement) { var locationObject = document.createElement("a"); locationObject.href = this.path; locationObject.pathname = locationObject.pathname.replace(regexMatch, suffixReplace); this.at_2x_path = locationObject.href } else { var parts = this.path.split("?"); parts[0] = parts[0].replace(regexMatch, suffixReplace); this.at_2x_path = parts.join("?") } this.perform_check = true } } root.RetinaImagePath = RetinaImagePath; RetinaImagePath.confirmed_paths = []; RetinaImagePath.prototype.is_external = function () { return !!(this.path.match(/^https?\:/i) && !this.path.match("//" + document.domain)) }; RetinaImagePath.prototype.check_2x_variant = function (callback) { var http, that = this; if (this.is_external()) { return callback(false) } else if (!this.perform_check && typeof this.at_2x_path !== "undefined" && this.at_2x_path !== null) { return callback(true) } else if (this.at_2x_path in RetinaImagePath.confirmed_paths) { return callback(true) } else { http = new XMLHttpRequest; http.open("HEAD", this.at_2x_path); http.onreadystatechange = function () { if (http.readyState !== 4) { return callback(false) } if (http.status >= 200 && http.status <= 399) { if (config.check_mime_type) { var type = http.getResponseHeader("Content-Type"); if (type === null || !type.match(/^image/i)) { return callback(false) } } RetinaImagePath.confirmed_paths.push(that.at_2x_path); return callback(true) } else { return callback(false) } }; http.send() } }; function RetinaImage(el) { this.el = el; this.path = new RetinaImagePath(this.el.getAttribute("src"), this.el.getAttribute("data-at2x")); var that = this; this.path.check_2x_variant(function (hasVariant) { if (hasVariant) { that.swap() } }) } root.RetinaImage = RetinaImage; RetinaImage.prototype.swap = function (path) { if (typeof path === "undefined") { path = this.path.at_2x_path } var that = this; function load() { if (!that.el.complete) { setTimeout(load, 5) } else { if (config.force_original_dimensions) { that.el.setAttribute("width", that.el.offsetWidth); that.el.setAttribute("height", that.el.offsetHeight) } that.el.setAttribute("src", path) } } load() }; if (Retina.isRetina()) { Retina.init(root) } })(); window.$ = jQuery.noConflict(); $(window).on("scroll load resize", function () { var startY = $(".navbar").height() * 1.5; if ($(window).scrollTop() > startY) { $(".navbar").addClass("scrolled"); $(".navbar").removeClass("notscrolled") } else { $(".navbar").removeClass("scrolled"); $(".navbar").addClass("notscrolled") } }); $(".scroll").click(function (event) { event.preventDefault(); var dest = 0; if ($(this.hash).offset().top > $(document).height() - $(window).height()) { dest = $(document).height() - $(window).height() } else { dest = $(this.hash).offset().top } $("html,body").animate({ scrollTop: dest }, 1e3, "swing") }); $(document).ready(function () { $("video").trigger("play") }); $(document).ready(function () { var tabs = new Array; var active_tab = 0; $(".expertise-section .expertise-data .nav-tabs").children().each(function (index) { tabs.push($(this).attr("tab-id")) }); $(".expertise-section .expertise-data .nav-tabs li").click(function () { active_tab = $(this).index(); $(".expertise-section .expertise-data .expertise-mobile-nav").find("span").html($(".expertise-section .expertise-data .nav-tabs li:nth-child(" + (active_tab + 1) + ")").find("a:first-child").html()) }); $("#expertise-next").click(function () { if (active_tab == tabs.length - 1) { active_tab = 0 } else { active_tab = active_tab + 1 } makeActive(active_tab) }); $("#expertise-prev").click(function () { if (active_tab == 0) { active_tab = tabs.length - 1 } else { active_tab = active_tab - 1 } makeActive(active_tab) }); function makeActive(active_tab) { $('.expertise-section .expertise-data .nav-tabs a[href="#' + tabs[active_tab] + '"]').tab("show"); $(".expertise-section .expertise-data .expertise-mobile-nav").find("span").html($(".expertise-section .expertise-data .nav-tabs li:nth-child(" + (active_tab + 1) + ")").find("a:first-child").html()) } }); $(document).ready(function () { var slides_count = $(".cb-feature-slider .carousel-indicators").children().length; var slides_img = new Array; $(".cb-feature-slider .carousel-indicators").children().each(function (index) { slides_img.push($(this).attr("data-img")) }); var active_tab = 0; var slide_autoplay = setInterval(nextSlide, 3e3); function goToSlide(new_index) { active_tab = new_index; $(".cb-feature-slider .carousel-indicators").find(".active").removeClass("active"); $(".cb-feature-slider .carousel-indicators li:nth-child(" + (new_index + 1) + ")").addClass("active"); $(".cb-feature-slider .cover").animate({}, "slow", function () { $(this).css({ "background-image": "url(" + slides_img[new_index] + ")" }) }); $(".cb-feature-slider .content .desktop-content").find(".wrap.active").removeClass("active"); $(".cb-feature-slider .content .desktop-content div.wrap:nth-child(" + (new_index + 1) + ")").addClass("active") } function nextSlide() { if (active_tab == slides_count - 1) { goToSlide(0) } else { goToSlide(active_tab + 1) } } $(".cb-feature-slider .carousel-indicators li").click(function () { goToSlide(parseInt($(this).attr("data-slide-to"))); clearTimeout(slide_autoplay); slide_autoplay = setInterval(nextSlide, 3e3) }) }); (function () { var e = [].slice; (function (t, n) { var r; return r = function () { function e(e) { var r = this; this.$el = t(e), t(n).resize(function () { return r.refresh() }) } return e.prototype.start = function () { var e, t, n, r; if (this._overlay_visible()) return !1; this._add_overlay_layer(), r = this.$el.find("*[data-intro]:visible"); for (t = 0, n = r.length; t < n; t++)e = r[t], this._show_element(e); return this.$el.trigger("chardinJs:start") }, e.prototype.toggle = function () { return this._overlay_visible() ? this.stop() : this.start() }, e.prototype.refresh = function () { var e, t, n, r, i; if (this._overlay_visible()) { r = this.$el.find("*[data-intro]:visible"), i = []; for (t = 0, n = r.length; t < n; t++)e = r[t], i.push(this._position_helper_layer(e)); return i } return this }, e.prototype.stop = function () { return this.$el.find(".chardinjs-overlay").fadeOut(function () { return t(this).remove() }), this.$el.find(".chardinjs-helper-layer").remove(), this.$el.find(".chardinjs-show-element").removeClass("chardinjs-show-element"), this.$el.find(".chardinjs-relative-position").removeClass("chardinjs-relative-position"), n.removeEventListener ? n.removeEventListener("keydown", this._onKeyDown, !0) : document.detachEvent && document.detachEvent("onkeydown", this._onKeyDown), this.$el.trigger("chardinJs:stop") }, e.prototype._overlay_visible = function () { return this.$el.find(".chardinjs-overlay").length !== 0 }, e.prototype._add_overlay_layer = function () { var e, t, n, r = this; return this._overlay_visible() ? !1 : (t = document.createElement("div"), n = "", t.className = "chardinjs-overlay", this.$el.prop("tagName") === "BODY" ? (n += "top: 0;bottom: 0; left: 0;right: 0;position: fixed;", t.setAttribute("style", n)) : (e = this._get_offset(this.$el.get()[0]), e && (n += "width: " + e.width + "px; height:" + e.height + "px; top:" + e.top + "px;left: " + e.left + "px;", t.setAttribute("style", n))), this.$el.get()[0].appendChild(t), t.onclick = function () { return r.stop() }, setTimeout(function () { return n += "opacity: .8;opacity: .8;-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=80)';filter: alpha(opacity=80);", t.setAttribute("style", n) }, 10)) }, e.prototype._get_position = function (e) { return e.getAttribute("data-position") || "bottom" }, e.prototype._place_tooltip = function (e) { var n, r, i, s, o, u, a; u = t(e).data("tooltip_layer"), a = this._get_offset(u), u.style.top = null, u.style.right = null, u.style.bottom = null, u.style.left = null; switch (this._get_position(e)) { case "top": case "bottom": i = this._get_offset(e), o = i.width, r = t(u).width(), u.style.left = "" + (o / 2 - a.width / 2) + "px"; break; case "left": case "right": i = this._get_offset(e), s = i.height, n = t(u).height(), u.style.top = "" + (s / 2 - a.height / 2) + "px" }switch (this._get_position(e)) { case "left": return u.style.left = "-" + (a.width - 34) + "px"; case "right": return u.style.right = "-" + (a.width - 34) + "px"; case "bottom": return u.style.bottom = "-" + a.height + "px"; case "top": return u.style.top = "-" + a.height + "px" } }, e.prototype._position_helper_layer = function (e) { var n, r; return r = t(e).data("helper_layer"), n = this._get_offset(e), r.setAttribute("style", "width: " + n.width + "px; height:" + n.height + "px; top:" + n.top + "px; left: " + n.left + "px;") }, e.prototype._show_element = function (e) { var n, r, i, s; r = this._get_offset(e), i = document.createElement("div"), s = document.createElement("div"), t(e).data("helper_layer", i).data("tooltip_layer", s), e.id && i.setAttribute("data-id", e.id), i.className = "chardinjs-helper-layer chardinjs-" + this._get_position(e), this._position_helper_layer(e), this.$el.get()[0].appendChild(i), s.className = "chardinjs-tooltip chardinjs-" + this._get_position(e), s.innerHTML = "<div class='chardinjs-tooltiptext'>" + e.getAttribute("data-intro") + "</div>", i.appendChild(s), this._place_tooltip(e), e.className += " chardinjs-show-element", n = "", e.currentStyle ? n = e.currentStyle.position : document.defaultView && document.defaultView.getComputedStyle && (n = document.defaultView.getComputedStyle(e, null).getPropertyValue("position")), n = n.toLowerCase(); if (n !== "absolute" && n !== "relative") return e.className += " chardinjs-relative-position" }, e.prototype._get_offset = function (e) { var t, n, r; t = { width: e.offsetWidth, height: e.offsetHeight }, n = 0, r = 0; while (e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop)) n += e.offsetLeft, r += e.offsetTop, e = e.offsetParent; return t.top = r, t.left = n, t }, e }(), t.fn.extend({ chardinJs: function () { var n, i, s, o; return o = arguments[0], i = 2 <= arguments.length ? e.call(arguments, 1) : [], n = t(this[0]), s = n.data("chardinJs"), s || n.data("chardinJs", s = new r(this, o)), typeof o == "string" && s[o].apply(s, i), s } }) })(window.jQuery, window) }).call(this); (function (factory) { if (typeof define === "function" && define.amd) { define(["jquery"], factory) } else if (typeof module === "object" && module.exports) { factory(require("jquery")) } else { factory(jQuery) } })(function ($) { var isOperaMini = Object.prototype.toString.call(window.operamini) === "[object OperaMini]"; var isInputSupported = "placeholder" in document.createElement("input") && !isOperaMini; var isTextareaSupported = "placeholder" in document.createElement("textarea") && !isOperaMini; var valHooks = $.valHooks; var propHooks = $.propHooks; var hooks; var placeholder; var settings = {}; if (isInputSupported && isTextareaSupported) { placeholder = $.fn.placeholder = function () { return this }; placeholder.input = true; placeholder.textarea = true } else { placeholder = $.fn.placeholder = function (options) { var defaults = { customClass: "placeholder" }; settings = $.extend({}, defaults, options); return this.filter((isInputSupported ? "textarea" : ":input") + "[placeholder]").not("." + settings.customClass).bind({ "focus.placeholder": clearPlaceholder, "blur.placeholder": setPlaceholder }).data("placeholder-enabled", true).trigger("blur.placeholder") }; placeholder.input = isInputSupported; placeholder.textarea = isTextareaSupported; hooks = { get: function (element) { var $element = $(element); var $passwordInput = $element.data("placeholder-password"); if ($passwordInput) { return $passwordInput[0].value } return $element.data("placeholder-enabled") && $element.hasClass(settings.customClass) ? "" : element.value }, set: function (element, value) { var $element = $(element); var $replacement; var $passwordInput; if (value !== "") { $replacement = $element.data("placeholder-textinput"); $passwordInput = $element.data("placeholder-password"); if ($replacement) { clearPlaceholder.call($replacement[0], true, value) || (element.value = value); $replacement[0].value = value } else if ($passwordInput) { clearPlaceholder.call(element, true, value) || ($passwordInput[0].value = value); element.value = value } } if (!$element.data("placeholder-enabled")) { element.value = value; return $element } if (value === "") { element.value = value; if (element != safeActiveElement()) { setPlaceholder.call(element) } } else { if ($element.hasClass(settings.customClass)) { clearPlaceholder.call(element) } element.value = value } return $element } }; if (!isInputSupported) { valHooks.input = hooks; propHooks.value = hooks } if (!isTextareaSupported) { valHooks.textarea = hooks; propHooks.value = hooks } $(function () { $(document).delegate("form", "submit.placeholder", function () { var $inputs = $("." + settings.customClass, this).each(function () { clearPlaceholder.call(this, true, "") }); setTimeout(function () { $inputs.each(setPlaceholder) }, 10) }) }); $(window).bind("beforeunload.placeholder", function () { $("." + settings.customClass).each(function () { this.value = "" }) }) } function args(elem) { var newAttrs = {}; var rinlinejQuery = /^jQuery\d+$/; $.each(elem.attributes, function (i, attr) { if (attr.specified && !rinlinejQuery.test(attr.name)) { newAttrs[attr.name] = attr.value } }); return newAttrs } function clearPlaceholder(event, value) { var input = this; var $input = $(input); if (input.value === $input.attr("placeholder") && $input.hasClass(settings.customClass)) { input.value = ""; $input.removeClass(settings.customClass); if ($input.data("placeholder-password")) { $input = $input.hide().nextAll('input[type="password"]:first').show().attr("id", $input.removeAttr("id").data("placeholder-id")); if (event === true) { $input[0].value = value; return value } $input.focus() } else { input == safeActiveElement() && input.select() } } } function setPlaceholder(event) { var $replacement; var input = this; var $input = $(input); var id = input.id; if (event && event.type === "blur") { if ($input.hasClass(settings.customClass)) { return } if (input.type === "password") { $replacement = $input.prevAll('input[type="text"]:first'); if ($replacement.length > 0 && $replacement.is(":visible")) { return } } } if (input.value === "") { if (input.type === "password") { if (!$input.data("placeholder-textinput")) { try { $replacement = $input.clone().prop({ type: "text" }) } catch (e) { $replacement = $("<input>").attr($.extend(args(this), { type: "text" })) } $replacement.removeAttr("name").data({ "placeholder-enabled": true, "placeholder-password": $input, "placeholder-id": id }).bind("focus.placeholder", clearPlaceholder); $input.data({ "placeholder-textinput": $replacement, "placeholder-id": id }).before($replacement) } input.value = ""; $input = $input.removeAttr("id").hide().prevAll('input[type="text"]:first').attr("id", $input.data("placeholder-id")).show() } else { var $passwordInput = $input.data("placeholder-password"); if ($passwordInput) { $passwordInput[0].value = ""; $input.attr("id", $input.data("placeholder-id")).show().nextAll('input[type="password"]:last').hide().removeAttr("id") } } $input.addClass(settings.customClass); $input[0].value = $input.attr("placeholder") } else { $input.removeClass(settings.customClass) } } function safeActiveElement() { try { return document.activeElement } catch (exception) { } } }); (function () { "use strict"; var keyCounter = 0; var allWaypoints = {}; function Waypoint(options) { if (!options) { throw new Error("No options passed to Waypoint constructor") } if (!options.element) { throw new Error("No element option passed to Waypoint constructor") } if (!options.handler) { throw new Error("No handler option passed to Waypoint constructor") } this.key = "waypoint-" + keyCounter; this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options); this.element = this.options.element; this.adapter = new Waypoint.Adapter(this.element); this.callback = options.handler; this.axis = this.options.horizontal ? "horizontal" : "vertical"; this.enabled = this.options.enabled; this.triggerPoint = null; this.group = Waypoint.Group.findOrCreate({ name: this.options.group, axis: this.axis }); this.context = Waypoint.Context.findOrCreateByElement(this.options.context); if (Waypoint.offsetAliases[this.options.offset]) { this.options.offset = Waypoint.offsetAliases[this.options.offset] } this.group.add(this); this.context.add(this); allWaypoints[this.key] = this; keyCounter += 1 } Waypoint.prototype.queueTrigger = function (direction) { this.group.queueTrigger(this, direction) }; Waypoint.prototype.trigger = function (args) { if (!this.enabled) { return } if (this.callback) { this.callback.apply(this, args) } }; Waypoint.prototype.destroy = function () { this.context.remove(this); this.group.remove(this); delete allWaypoints[this.key] }; Waypoint.prototype.disable = function () { this.enabled = false; return this }; Waypoint.prototype.enable = function () { this.context.refresh(); this.enabled = true; return this }; Waypoint.prototype.next = function () { return this.group.next(this) }; Waypoint.prototype.previous = function () { return this.group.previous(this) }; Waypoint.invokeAll = function (method) { var allWaypointsArray = []; for (var waypointKey in allWaypoints) { allWaypointsArray.push(allWaypoints[waypointKey]) } for (var i = 0, end = allWaypointsArray.length; i < end; i++) { allWaypointsArray[i][method]() } }; Waypoint.destroyAll = function () { Waypoint.invokeAll("destroy") }; Waypoint.disableAll = function () { Waypoint.invokeAll("disable") }; Waypoint.enableAll = function () { Waypoint.invokeAll("enable") }; Waypoint.refreshAll = function () { Waypoint.Context.refreshAll() }; Waypoint.viewportHeight = function () { return window.innerHeight || document.documentElement.clientHeight }; Waypoint.viewportWidth = function () { return document.documentElement.clientWidth }; Waypoint.adapters = []; Waypoint.defaults = { context: window, continuous: true, enabled: true, group: "default", horizontal: false, offset: 0 }; Waypoint.offsetAliases = { "bottom-in-view": function () { return this.context.innerHeight() - this.adapter.outerHeight() }, "right-in-view": function () { return this.context.innerWidth() - this.adapter.outerWidth() } }; window.Waypoint = Waypoint })(); (function () { "use strict"; function requestAnimationFrameShim(callback) { window.setTimeout(callback, 1e3 / 60) } var keyCounter = 0; var contexts = {}; var Waypoint = window.Waypoint; var oldWindowLoad = window.onload; function Context(element) { this.element = element; this.Adapter = Waypoint.Adapter; this.adapter = new this.Adapter(element); this.key = "waypoint-context-" + keyCounter; this.didScroll = false; this.didResize = false; this.oldScroll = { x: this.adapter.scrollLeft(), y: this.adapter.scrollTop() }; this.waypoints = { vertical: {}, horizontal: {} }; element.waypointContextKey = this.key; contexts[element.waypointContextKey] = this; keyCounter += 1; this.createThrottledScrollHandler(); this.createThrottledResizeHandler() } Context.prototype.add = function (waypoint) { var axis = waypoint.options.horizontal ? "horizontal" : "vertical"; this.waypoints[axis][waypoint.key] = waypoint; this.refresh() }; Context.prototype.checkEmpty = function () { var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal); var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical); if (horizontalEmpty && verticalEmpty) { this.adapter.off(".waypoints"); delete contexts[this.key] } }; Context.prototype.createThrottledResizeHandler = function () { var self = this; function resizeHandler() { self.handleResize(); self.didResize = false } this.adapter.on("resize.waypoints", function () { if (!self.didResize) { self.didResize = true; Waypoint.requestAnimationFrame(resizeHandler) } }) }; Context.prototype.createThrottledScrollHandler = function () { var self = this; function scrollHandler() { self.handleScroll(); self.didScroll = false } this.adapter.on("scroll.waypoints", function () { if (!self.didScroll || Waypoint.isTouch) { self.didScroll = true; Waypoint.requestAnimationFrame(scrollHandler) } }) }; Context.prototype.handleResize = function () { Waypoint.Context.refreshAll() }; Context.prototype.handleScroll = function () { var triggeredGroups = {}; var axes = { horizontal: { newScroll: this.adapter.scrollLeft(), oldScroll: this.oldScroll.x, forward: "right", backward: "left" }, vertical: { newScroll: this.adapter.scrollTop(), oldScroll: this.oldScroll.y, forward: "down", backward: "up" } }; for (var axisKey in axes) { var axis = axes[axisKey]; var isForward = axis.newScroll > axis.oldScroll; var direction = isForward ? axis.forward : axis.backward; for (var waypointKey in this.waypoints[axisKey]) { var waypoint = this.waypoints[axisKey][waypointKey]; var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint; var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint; var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint; var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint; if (crossedForward || crossedBackward) { waypoint.queueTrigger(direction); triggeredGroups[waypoint.group.id] = waypoint.group } } } for (var groupKey in triggeredGroups) { triggeredGroups[groupKey].flushTriggers() } this.oldScroll = { x: axes.horizontal.newScroll, y: axes.vertical.newScroll } }; Context.prototype.innerHeight = function () { if (this.element == this.element.window) { return Waypoint.viewportHeight() } return this.adapter.innerHeight() }; Context.prototype.remove = function (waypoint) { delete this.waypoints[waypoint.axis][waypoint.key]; this.checkEmpty() }; Context.prototype.innerWidth = function () { if (this.element == this.element.window) { return Waypoint.viewportWidth() } return this.adapter.innerWidth() }; Context.prototype.destroy = function () { var allWaypoints = []; for (var axis in this.waypoints) { for (var waypointKey in this.waypoints[axis]) { allWaypoints.push(this.waypoints[axis][waypointKey]) } } for (var i = 0, end = allWaypoints.length; i < end; i++) { allWaypoints[i].destroy() } }; Context.prototype.refresh = function () { var isWindow = this.element == this.element.window; var contextOffset = isWindow ? undefined : this.adapter.offset(); var triggeredGroups = {}; var axes; this.handleScroll(); axes = { horizontal: { contextOffset: isWindow ? 0 : contextOffset.left, contextScroll: isWindow ? 0 : this.oldScroll.x, contextDimension: this.innerWidth(), oldScroll: this.oldScroll.x, forward: "right", backward: "left", offsetProp: "left" }, vertical: { contextOffset: isWindow ? 0 : contextOffset.top, contextScroll: isWindow ? 0 : this.oldScroll.y, contextDimension: this.innerHeight(), oldScroll: this.oldScroll.y, forward: "down", backward: "up", offsetProp: "top" } }; for (var axisKey in axes) { var axis = axes[axisKey]; for (var waypointKey in this.waypoints[axisKey]) { var waypoint = this.waypoints[axisKey][waypointKey]; var adjustment = waypoint.options.offset; var oldTriggerPoint = waypoint.triggerPoint; var elementOffset = 0; var freshWaypoint = oldTriggerPoint == null; var contextModifier, wasBeforeScroll, nowAfterScroll; var triggeredBackward, triggeredForward; if (waypoint.element !== waypoint.element.window) { elementOffset = waypoint.adapter.offset()[axis.offsetProp] } if (typeof adjustment === "function") { adjustment = adjustment.apply(waypoint) } else if (typeof adjustment === "string") { adjustment = parseFloat(adjustment); if (waypoint.options.offset.indexOf("%") > -1) { adjustment = Math.ceil(axis.contextDimension * adjustment / 100) } } contextModifier = axis.contextScroll - axis.contextOffset; waypoint.triggerPoint = elementOffset + contextModifier - adjustment; wasBeforeScroll = oldTriggerPoint < axis.oldScroll; nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll; triggeredBackward = wasBeforeScroll && nowAfterScroll; triggeredForward = !wasBeforeScroll && !nowAfterScroll; if (!freshWaypoint && triggeredBackward) { waypoint.queueTrigger(axis.backward); triggeredGroups[waypoint.group.id] = waypoint.group } else if (!freshWaypoint && triggeredForward) { waypoint.queueTrigger(axis.forward); triggeredGroups[waypoint.group.id] = waypoint.group } else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) { waypoint.queueTrigger(axis.forward); triggeredGroups[waypoint.group.id] = waypoint.group } } } Waypoint.requestAnimationFrame(function () { for (var groupKey in triggeredGroups) { triggeredGroups[groupKey].flushTriggers() } }); return this }; Context.findOrCreateByElement = function (element) { return Context.findByElement(element) || new Context(element) }; Context.refreshAll = function () { for (var contextId in contexts) { contexts[contextId].refresh() } }; Context.findByElement = function (element) { return contexts[element.waypointContextKey] }; window.onload = function () { if (oldWindowLoad) { oldWindowLoad() } Context.refreshAll() }; Waypoint.requestAnimationFrame = function (callback) { var requestFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || requestAnimationFrameShim; requestFn.call(window, callback) }; Waypoint.Context = Context })(); (function () { "use strict"; function byTriggerPoint(a, b) { return a.triggerPoint - b.triggerPoint } function byReverseTriggerPoint(a, b) { return b.triggerPoint - a.triggerPoint } var groups = { vertical: {}, horizontal: {} }; var Waypoint = window.Waypoint; function Group(options) { this.name = options.name; this.axis = options.axis; this.id = this.name + "-" + this.axis; this.waypoints = []; this.clearTriggerQueues(); groups[this.axis][this.name] = this } Group.prototype.add = function (waypoint) { this.waypoints.push(waypoint) }; Group.prototype.clearTriggerQueues = function () { this.triggerQueues = { up: [], down: [], left: [], right: [] } }; Group.prototype.flushTriggers = function () { for (var direction in this.triggerQueues) { var waypoints = this.triggerQueues[direction]; var reverse = direction === "up" || direction === "left"; waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint); for (var i = 0, end = waypoints.length; i < end; i += 1) { var waypoint = waypoints[i]; if (waypoint.options.continuous || i === waypoints.length - 1) { waypoint.trigger([direction]) } } } this.clearTriggerQueues() }; Group.prototype.next = function (waypoint) { this.waypoints.sort(byTriggerPoint); var index = Waypoint.Adapter.inArray(waypoint, this.waypoints); var isLast = index === this.waypoints.length - 1; return isLast ? null : this.waypoints[index + 1] }; Group.prototype.previous = function (waypoint) { this.waypoints.sort(byTriggerPoint); var index = Waypoint.Adapter.inArray(waypoint, this.waypoints); return index ? this.waypoints[index - 1] : null }; Group.prototype.queueTrigger = function (waypoint, direction) { this.triggerQueues[direction].push(waypoint) }; Group.prototype.remove = function (waypoint) { var index = Waypoint.Adapter.inArray(waypoint, this.waypoints); if (index > -1) { this.waypoints.splice(index, 1) } }; Group.prototype.first = function () { return this.waypoints[0] }; Group.prototype.last = function () { return this.waypoints[this.waypoints.length - 1] }; Group.findOrCreate = function (options) { return groups[options.axis][options.name] || new Group(options) }; Waypoint.Group = Group })(); (function () { "use strict"; var $ = window.jQuery; var Waypoint = window.Waypoint; function JQueryAdapter(element) { this.$element = $(element) } $.each(["innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop"], function (i, method) { JQueryAdapter.prototype[method] = function () { var args = Array.prototype.slice.call(arguments); return this.$element[method].apply(this.$element, args) } }); $.each(["extend", "inArray", "isEmptyObject"], function (i, method) { JQueryAdapter[method] = $[method] }); Waypoint.adapters.push({ name: "jquery", Adapter: JQueryAdapter }); Waypoint.Adapter = JQueryAdapter })(); (function () { "use strict"; var Waypoint = window.Waypoint; function createExtension(framework) { return function () { var waypoints = []; var overrides = arguments[0]; if (framework.isFunction(arguments[0])) { overrides = framework.extend({}, arguments[1]); overrides.handler = arguments[0] } this.each(function () { var options = framework.extend({}, overrides, { element: this }); if (typeof options.context === "string") { options.context = framework(this).closest(options.context)[0] } waypoints.push(new Waypoint(options)) }); return waypoints } } if (window.jQuery) { window.jQuery.fn.waypoint = createExtension(window.jQuery) } if (window.Zepto) { window.Zepto.fn.waypoint = createExtension(window.Zepto) } })(); (function ($) { "use strict"; function onScrollAnimations() { $(".wp-1").waypoint(function () { $(".wp-1").addClass("animated fadeInUp") }, { offset: "75%" }); $(".wp-2").waypoint(function () { $(".wp-2").addClass("animated fadeInUp") }, { offset: "75%" }); $(".wp-3").waypoint(function () { $(".wp-3").addClass("animated fadeInUp") }, { offset: "75%" }); $(".wp-4").waypoint(function () { $(".wp-4").addClass("animated fadeIn") }, { offset: "75%" }); $(".wp-5").waypoint(function () { $(".wp-5").addClass("animated fadeInRight") }, { offset: "50%" }); $(".wp-6").waypoint(function () { $(".wp-6").addClass("animated fadeInLeft") }, { offset: "50%" }); $(".wp-7").waypoint(function () { $(".wp-7").addClass("animated fadeInUp") }, { offset: "60%" }); $(".wp-8").waypoint(function () { $(".wp-8").addClass("animated fadeInUp") }, { offset: "60%" }) } function inputPlaceholders() { $("input, textarea").placeholder() } function navMobileCollapse() { $("#collapsingMobileUser").on("show.bs.collapse", function () { $("#collapsingNavbar").removeClass("in"); $('[data-target="#collapsingNavbar"]').attr("aria-expanded", "false") }); $("#collapsingNavbar").on("show.bs.collapse", function () { $("#collapsingMobileUser").removeClass("in"); $('[data-target="#collapsingMobileUser"]').attr("aria-expanded", "false") }); $("#collapsingMobileUserInverse").on("show.bs.collapse", function () { $("#collapsingNavbarInverse").removeClass("in"); $('[data-target="#collapsingNavbarInverse"]').attr("aria-expanded", "false") }); $("#collapsingNavbarInverse").on("show.bs.collapse", function () { $("#collapsingMobileUserInverse").removeClass("in"); $('[data-target="#collapsingMobileUserInverse"]').attr("aria-expanded", "false") }) } function navSearch() { $(".nav-dropdown-search").on("show.bs.dropdown", function () { $(this).siblings().not(".navbar-nav .dropdown").addClass("sr-only") }); $(".nav-dropdown-search").on("shown.bs.dropdown", function () { $(".navbar-search-input").focus() }); $(".nav-dropdown-search").on("hide.bs.dropdown", function () { $(this).siblings().removeClass("sr-only") }) } function htmlVideo() { videojs("demo_video", { controlBar: { timeDivider: false, fullscreenToggle: false, playToggle: false, remainingTimeDisplay: false }, height: "auto", width: "auto" }).ready(function () { var myPlayer = this; var aspectRatio = 5 / 12; function resizeVideoJS() { var width = document.getElementById(myPlayer.id()).parentElement.offsetWidth; myPlayer.width(width).height(width * aspectRatio) } resizeVideoJS(); window.onresize = resizeVideoJS }) } function scrollToTop() { $(".scroll-top").on("click", function () { $("html, body").animate({ scrollTop: 0 }, 1e3); return false }) } function donutChart() { var doughnutData = [{ value: 324, color: "#5e98e3", highlight: "#424753", label: "Completed" }, { value: 34, color: "#59d0bd", highlight: "#424753", label: "In backlog" }, { value: 20, color: "#e8e9ec", highlight: "#424753", label: "Without ticket" }]; window.onload = function () { var c = document.getElementById("chart-area"); if (c != null) { var ctx = c.getContext("2d"); window.myDoughnut = new Chart(ctx).Doughnut(doughnutData, { responsive: true, percentageInnerCutout: 80 }) } else { return false } } } function videoModal() { $("#videoModal").on("shown.bs.modal", function () { $("#vimeo-play").vimeo("play") }); $("#videoModal").on("hidden.bs.modal", function () { $("#vimeo-play").vimeo("pause") }); $("#youtube-trigger").click(function () { var videoSRC = $(this).attr("data-video"), videoSRCauto = videoSRC + "?autoplay=1&html5=1&rel=0&showinfo=0"; $("#youtubeModal").on("shown.bs.modal", function () { $("#youtube-play").attr("src", videoSRCauto) }); $("#youtubeModal").on("hidden.bs.modal", function () { $("#youtube-play").attr("src", videoSRC) }) }) } function init() { onScrollAnimations(); inputPlaceholders(); navMobileCollapse(); navSearch(); htmlVideo(); scrollToTop(); donutChart(); videoModal() } init() })(jQuery);